name: "\U0001F504 Refresh Testsystem"

# ============================================================================
# Combined workflow to refresh the staging/test environment:
#   1. Deploy code from any branch to the test server
#   2. Sync the production database (Hetzner) directly to the test server
#
# Runs on the self-hosted runner (Home Server), so it has direct Docker access.
# For DB sync, it uses the DEPLOY_SSH_KEY secret to SSH into Hetzner.
#
# Progress is reported via GitHub Job Summaries (visible on the workflow run page).
# ============================================================================

on:
  workflow_dispatch:
    inputs:
      deploy_code:
        description: "\U0001F680 Deploy code to Staging"
        type: boolean
        default: true
      branch:
        description: "\U0001F33F Branch to deploy (only used if 'Deploy code' is enabled)"
        type: string
        default: "master"
      sync_database:
        description: "\U0001F5C4Ô∏è Sync database from Production (Hetzner) to Staging"
        type: boolean
        default: false

jobs:
  validate-inputs:
    runs-on: self-hosted
    outputs:
      start_time: ${{ steps.init.outputs.start_time }}
    steps:
      - name: Validate & Initialize
        id: init
        run: |
          if [ "${{ inputs.deploy_code }}" != "true" ] && [ "${{ inputs.sync_database }}" != "true" ]; then
            echo "## ‚ùå Validation Failed" >> $GITHUB_STEP_SUMMARY
            echo "You must select at least one action." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

          # --- Job Summary: Header ---
          echo "## üîÑ Refresh Testsystem" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Deploy Code** | \`${{ inputs.deploy_code }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ inputs.branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Sync Database** | \`${{ inputs.sync_database }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered by** | \`${{ github.actor }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Started at** | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  # =====================================================================
  # PHASE 1: CODE DEPLOYMENT
  # =====================================================================
  deploy-code:
    if: ${{ inputs.deploy_code }}
    needs: validate-inputs
    runs-on: self-hosted
    env:
      DOMAIN_NAME: test.skuld-options.com
      AUTH_DOMAIN: auth-test.skuld-options.com
      COMPOSE_HTTP_TIMEOUT: "300"
      DOCKER_CLIENT_TIMEOUT: "300"

    steps:
      - name: "üìã Summary: Deploy started"
        run: |
          echo "## üöÄ Phase 1: Code Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|---------|" >> $GITHUB_STEP_SUMMARY

      - name: Fix Permissions (Pre-Checkout)
        run: |
          if [ -d . ]; then
             docker run --rm -v "$(pwd):/clean" alpine chown -R $(id -u):$(id -g) /clean || true
          fi
          echo "| üîß Fix Permissions | ‚úÖ Done | ‚Äî |" >> $GITHUB_STEP_SUMMARY

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0

      - name: Get version info
        id: version
        run: |
          COUNT=$(git rev-list --count HEAD)
          HASH=$(git rev-parse --short HEAD)
          DATE=$(git log -1 --format=%cd --date=format:'%Y-%m-%d %H:%M')
          BRANCH="${{ inputs.branch }}"
          VERSION="${COUNT}-${HASH} [${BRANCH}] (${DATE})"
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "| üìã Checkout | ‚úÖ Done | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY

      - name: Create .env file for Staging
        run: |
          echo "DOMAIN_NAME=${{ env.DOMAIN_NAME }}" > .env
          echo "AUTH_DOMAIN=${{ env.AUTH_DOMAIN }}" >> .env
          echo "TRAEFIK_ENTRYPOINT=web" >> .env
          echo "TRAEFIK_CERTRESOLVER_LABEL_SKULD=traefik.enable=true" >> .env
          echo "TRAEFIK_CERTRESOLVER_LABEL_AUTHELIA=traefik.enable=true" >> .env
          echo "AUTH_SCHEME=http" >> .env
          echo "TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}" >> .env
          echo "TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID_STAGING }}" >> .env
          echo "SKULD_ENV=Staging" >> .env
          echo "MASSIVE_API_KEY=${{ secrets.MASSIVE_API_KEY }}" >> .env
          echo "MASSIVE_API_KEY_FLAT_FILES=${{ secrets.MASSIVE_API_KEY_FLAT_FILES }}" >> .env
          echo "POSTGRES_HOST=postgres" >> .env
          echo "POSTGRES_DB=Skuld" >> .env
          echo "POSTGRES_USER=admin" >> .env
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env
          echo "POSTGRES_PORT=5432" >> .env
          echo "SKULD_VERSION=${{ steps.version.outputs.VERSION }}" >> .env
          echo "| ‚öôÔ∏è Create .env | ‚úÖ Done | Staging config |" >> $GITHUB_STEP_SUMMARY

      - name: Setup Authelia for Staging
        run: |
          mkdir -p authelia
          echo "${{ secrets.AUTHELIA_JWT_SECRET }}" > authelia/jwt_secret
          echo "${{ secrets.AUTHELIA_SESSION_SECRET }}" > authelia/session_secret
          echo "${{ secrets.AUTHELIA_STORAGE_ENCRYPTION_KEY }}" > authelia/storage_encryption_key

          AUTHELIA_HASH='${{ secrets.AUTHELIA_PASSWORD_HASH }}'
          echo "users:" > authelia/users_database.yml
          echo "  admin:" >> authelia/users_database.yml
          echo "    displayname: \"Staging Admin\"" >> authelia/users_database.yml
          echo "    password: \"$AUTHELIA_HASH\"" >> authelia/users_database.yml
          echo "    email: admin@staging.skuld.com" >> authelia/users_database.yml
          echo "    groups:" >> authelia/users_database.yml
          echo "      - admins" >> authelia/users_database.yml
          echo "      - dev" >> authelia/users_database.yml

          sed -i "s/app.skuld-options.com/${{ env.DOMAIN_NAME }}/g" authelia/configuration.yml
          echo "| üîê Setup Authelia | ‚úÖ Done | ‚Äî |" >> $GITHUB_STEP_SUMMARY

      - name: Clean up & Ensure Networks
        run: |
          docker system prune -f || true

          for NET in web postgres_setup_default; do
            if ! docker network inspect $NET >/dev/null 2>&1; then
              docker network create $NET
            fi
          done
          echo "| üßπ Cleanup & Networks | ‚úÖ Done | ‚Äî |" >> $GITHUB_STEP_SUMMARY

      - name: "üê≥ Docker Build & Deploy"
        run: |
          docker compose down --remove-orphans || true

          if [ -d "financial_data.db" ]; then
            rm -rf financial_data.db && touch financial_data.db
          elif [ ! -f "financial_data.db" ]; then
            touch financial_data.db
          fi

          # --- Build ---
          BUILD_START=$(date +%s)
          docker build -t skuld-app-image .
          BUILD_DURATION=$(( $(date +%s) - BUILD_START ))
          echo "| üê≥ Docker Build | ‚úÖ Done | ${BUILD_DURATION}s |" >> $GITHUB_STEP_SUMMARY

          # --- Pull ---
          PULL_START=$(date +%s)
          n=0
          until [ "$n" -ge 5 ]; do
             docker compose -f docker-compose.yml -f docker-compose.testing.yml pull && break
             n=$((n+1))
             sleep 10
          done
          if [ "$n" -ge 5 ]; then
             echo "| üì• Pull Images | ‚ùå Failed | After 5 attempts |" >> $GITHUB_STEP_SUMMARY
             exit 1
          fi
          PULL_DURATION=$(( $(date +%s) - PULL_START ))
          echo "| üì• Pull Images | ‚úÖ Done | ${PULL_DURATION}s |" >> $GITHUB_STEP_SUMMARY

          # --- Start ---
          docker compose -f docker-compose.yml -f docker-compose.testing.yml up -d --no-build --remove-orphans
          docker builder prune -f
          echo "| ‚ñ∂Ô∏è Start Stack | ‚úÖ Done | ‚Äî |" >> $GITHUB_STEP_SUMMARY

      - name: "üìã Summary: Container Status"
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details><summary>üê≥ Container Status after Deploy</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          docker compose -f docker-compose.yml -f docker-compose.testing.yml ps 2>/dev/null || docker ps
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  # =====================================================================
  # PHASE 2: DATABASE SYNC
  # =====================================================================
  sync-database:
    needs: [validate-inputs, deploy-code]
    if: ${{ inputs.sync_database && (needs.deploy-code.result == 'success' || needs.deploy-code.result == 'skipped') }}
    runs-on: self-hosted
    env:
      STAGING_DB_CONTAINER: skuld_staging_db
      STAGING_DB_NAME: Skuld
      STAGING_DB_USER: admin
      DUMP_PATH: /tmp/skuld_restore.sql.gz

    steps:
      - name: "üìã Summary: DB Sync started"
        run: |
          echo "## üóÑÔ∏è Phase 2: Database Sync" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|---------|" >> $GITHUB_STEP_SUMMARY

      - name: Setup SSH for Hetzner Access
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/hetzner_key
          chmod 600 ~/.ssh/hetzner_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "| üîë SSH Setup | ‚úÖ Done | ‚Äî |" >> $GITHUB_STEP_SUMMARY

      - name: Verify Staging DB Container
        run: |
          if ! docker ps --format '{{.Names}}' | grep -q "^${{ env.STAGING_DB_CONTAINER }}$"; then
            echo "| üîç Verify DB Container | ‚ùå Not running | Deploy code first! |" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          echo "| üîç Verify DB Container | ‚úÖ Running | \`${{ env.STAGING_DB_CONTAINER }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: "‚¨áÔ∏è Download Backup from Hetzner"
        id: download
        run: |
          DL_START=$(date +%s)

          SSH_OPTS="-i ~/.ssh/hetzner_key -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o ServerAliveInterval=30 -o ServerAliveCountMax=3"

          echo "üîç Finding latest backup on Hetzner..."
          LATEST=$(ssh $SSH_OPTS \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "ls -t ~/backups/postgres/skuld_*.sql.gz 2>/dev/null | head -n 1")

          if [ -z "$LATEST" ]; then
            echo "| ‚¨áÔ∏è Download Backup | ‚ùå Failed | No backup found |" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          FILENAME=$(basename "$LATEST")

          # Get exact file size for progress calculation
          REMOTE_BYTES=$(ssh $SSH_OPTS \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "stat -c%s '$LATEST'")
          REMOTE_SIZE_HR=$(numfmt --to=iec-i --suffix=B $REMOTE_BYTES 2>/dev/null || echo "${REMOTE_BYTES} bytes")

          echo "üì¶ Backup: $FILENAME ($REMOTE_SIZE_HR)"

          # ---------------------------------------------------------------
          # rsync download with auto-retry and resume on SSH disconnect
          #
          # Flags:
          #   --progress    : show per-file transfer progress
          #   --partial     : keep partial file on interrupt (enables resume)
          #   --timeout=120 : abort if no data received for 120s
          #   --append-verify : resume from where it left off + checksum verify
          #
          # Retry logic:
          #   Up to 5 attempts with 15s wait between retries.
          #   rsync + --partial + --append-verify means each retry continues
          #   where the last one stopped instead of re-downloading from scratch.
          # ---------------------------------------------------------------
          MAX_RETRIES=5
          ATTEMPT=0
          RSYNC_EXIT=1

          while [ $ATTEMPT -lt $MAX_RETRIES ] && [ $RSYNC_EXIT -ne 0 ]; do
            ATTEMPT=$((ATTEMPT + 1))

            if [ $ATTEMPT -eq 1 ]; then
              echo "‚¨áÔ∏è  Starting download (attempt ${ATTEMPT}/${MAX_RETRIES})..."
              # First attempt: clean start
              rm -f ${{ env.DUMP_PATH }}
            else
              PARTIAL_SIZE="0"
              if [ -f "${{ env.DUMP_PATH }}" ]; then
                PARTIAL_SIZE=$(du -h "${{ env.DUMP_PATH }}" | cut -f1)
              fi
              echo ""
              echo "üîÑ Retry ${ATTEMPT}/${MAX_RETRIES} (resuming from ${PARTIAL_SIZE})..."
            fi

            # Run rsync in background, monitor file-size progress in foreground.
            # rsync --progress uses \r which doesn't produce visible output in
            # non-TTY CI environments, so we track size ourselves instead.
            rsync --partial --append-verify --timeout=120 \
              -e "ssh $SSH_OPTS" \
              "${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${LATEST}" \
              ${{ env.DUMP_PATH }} > /dev/null 2>&1 &
            RSYNC_PID=$!

            # Print progress + speed every 10s while rsync is running
            LAST_PCT=-1
            PREV_BYTES=0
            PREV_TIME=$(date +%s)
            while kill -0 $RSYNC_PID 2>/dev/null; do
              if [ -f "${{ env.DUMP_PATH }}" ]; then
                CUR=$(stat -c%s "${{ env.DUMP_PATH }}" 2>/dev/null || echo 0)
                NOW=$(date +%s)
                PCT=$((CUR * 100 / REMOTE_BYTES))
                CUR_HR=$(numfmt --to=iec-i --suffix=B $CUR 2>/dev/null || echo "${CUR}")

                # Calculate speed since last check
                ELAPSED=$((NOW - PREV_TIME))
                if [ "$ELAPSED" -gt 0 ] && [ "$CUR" -gt "$PREV_BYTES" ]; then
                  SPEED=$(( (CUR - PREV_BYTES) / ELAPSED ))
                  SPEED_HR=$(numfmt --to=iec-i --suffix=B/s $SPEED 2>/dev/null || echo "${SPEED} B/s")
                  # ETA calculation
                  REMAINING=$((REMOTE_BYTES - CUR))
                  if [ "$SPEED" -gt 0 ]; then
                    ETA_SECS=$((REMAINING / SPEED))
                    ETA_MIN=$((ETA_SECS / 60))
                    ETA_SEC=$((ETA_SECS % 60))
                    ETA_STR="${ETA_MIN}m ${ETA_SEC}s"
                  else
                    ETA_STR="--"
                  fi
                  echo "üì• ${CUR_HR} / ${REMOTE_SIZE_HR}  (${PCT}%)  ‚ö° ${SPEED_HR}  ETA: ${ETA_STR}"
                elif [ "$PCT" -ne "$LAST_PCT" ]; then
                  echo "üì• ${CUR_HR} / ${REMOTE_SIZE_HR}  (${PCT}%)"
                fi

                PREV_BYTES=$CUR
                PREV_TIME=$NOW
                LAST_PCT=$PCT
              fi
              sleep 10
            done

            wait $RSYNC_PID
            RSYNC_EXIT=$?

            if [ $RSYNC_EXIT -ne 0 ]; then
              echo "‚ö†Ô∏è  rsync exited with code ${RSYNC_EXIT}"
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "   Waiting 15s before retry..."
                sleep 15
              fi
            fi
          done

          if [ $RSYNC_EXIT -ne 0 ]; then
            echo ""
            echo "‚ùå rsync failed after ${MAX_RETRIES} attempts (last exit code: ${RSYNC_EXIT})"
            echo "| ‚¨áÔ∏è Download Backup | ‚ùå Failed | rsync failed after ${MAX_RETRIES} retries |" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Verify downloaded file size matches remote
          LOCAL_BYTES=$(stat -c%s "${{ env.DUMP_PATH }}" 2>/dev/null || echo "0")
          if [ "$LOCAL_BYTES" -ne "$REMOTE_BYTES" ]; then
            echo "‚ö†Ô∏è  Size mismatch! Local: ${LOCAL_BYTES} vs Remote: ${REMOTE_BYTES}"
            echo "| ‚¨áÔ∏è Download Backup | ‚ùå Failed | Size mismatch |" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          DL_DURATION=$(( $(date +%s) - DL_START ))
          LOCAL_SIZE=$(du -h ${{ env.DUMP_PATH }} | cut -f1)
          DL_MIN=$(( DL_DURATION / 60 ))
          DL_SEC=$(( DL_DURATION % 60 ))

          if [ "$DL_DURATION" -gt 0 ] && [ "$LOCAL_BYTES" -gt 0 ]; then
            AVG_SPEED=$(( LOCAL_BYTES / DL_DURATION ))
            AVG_SPEED_HR=$(numfmt --to=iec-i --suffix=B/s $AVG_SPEED 2>/dev/null || echo "")
            echo ""
            echo "‚úÖ Download complete: ${LOCAL_SIZE} in ${DL_MIN}m ${DL_SEC}s (avg: ${AVG_SPEED_HR}, ${ATTEMPT} attempt(s))"
          else
            echo ""
            echo "‚úÖ Download complete: ${LOCAL_SIZE} in ${DL_MIN}m ${DL_SEC}s"
          fi

          echo "backup_file=$FILENAME" >> $GITHUB_OUTPUT
          echo "backup_size=$LOCAL_SIZE" >> $GITHUB_OUTPUT

          echo "| ‚¨áÔ∏è Download Backup | ‚úÖ Done | \`${FILENAME}\` (${LOCAL_SIZE}, ${DL_MIN}m ${DL_SEC}s, ${ATTEMPT} attempt(s)) |" >> $GITHUB_STEP_SUMMARY

      - name: "üîÑ Restore Database"
        run: |
          RESTORE_START=$(date +%s)

          echo "‚è∏Ô∏è Stopping application services..."
          docker stop skuld-frontend skuld-backend 2>/dev/null || true
          sleep 3

          echo "üóëÔ∏è Dropping and recreating database..."
          echo "DROP DATABASE IF EXISTS \"${{ env.STAGING_DB_NAME }}\"; CREATE DATABASE \"${{ env.STAGING_DB_NAME }}\";" | \
            docker exec -i ${{ env.STAGING_DB_CONTAINER }} psql -U ${{ env.STAGING_DB_USER }} -d postgres

          # Get dump size for progress estimation
          DUMP_SIZE=$(stat -c%s "${{ env.DUMP_PATH }}" 2>/dev/null || echo "0")
          DUMP_SIZE_HR=$(numfmt --to=iec-i --suffix=B $DUMP_SIZE 2>/dev/null || echo "unknown")
          echo "üì• Restoring from dump (${DUMP_SIZE_HR} compressed)..."
          echo "   This may take several minutes depending on database size."

          # Restore directly without line counting.
          # pg_dump uses COPY commands which don't output line-by-line progress,
          # so line counting doesn't work well and can buffer/block.
          zcat ${{ env.DUMP_PATH }} | \
            docker exec -i ${{ env.STAGING_DB_CONTAINER }} psql -U ${{ env.STAGING_DB_USER }} -d ${{ env.STAGING_DB_NAME }}

          echo "‚ñ∂Ô∏è Restarting application services..."
          docker start skuld-frontend skuld-backend 2>/dev/null || true

          RESTORE_DURATION=$(( $(date +%s) - RESTORE_START ))
          RESTORE_MIN=$(( RESTORE_DURATION / 60 ))
          RESTORE_SEC=$(( RESTORE_DURATION % 60 ))
          echo "‚úÖ Restore complete in ${RESTORE_MIN}m ${RESTORE_SEC}s"
          echo "| üîÑ Restore Database | ‚úÖ Done | ${RESTORE_MIN}m ${RESTORE_SEC}s |" >> $GITHUB_STEP_SUMMARY

      - name: "‚úÖ Verify Database"
        run: |
          TABLE_COUNT=$(docker exec ${{ env.STAGING_DB_CONTAINER }} psql -U ${{ env.STAGING_DB_USER }} -d ${{ env.STAGING_DB_NAME }} \
            -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public';" | tr -d ' ')

          echo "| ‚úÖ Verify Database | ‚úÖ Done | ${TABLE_COUNT} tables |" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details><summary>üìä Top 15 Tables by Size</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          docker exec ${{ env.STAGING_DB_CONTAINER }} psql -U ${{ env.STAGING_DB_USER }} -d ${{ env.STAGING_DB_NAME }} \
            -c "SELECT tablename, pg_size_pretty(pg_total_relation_size(quote_ident(tablename)::regclass)) as size FROM pg_tables WHERE schemaname = 'public' ORDER BY pg_total_relation_size(quote_ident(tablename)::regclass) DESC LIMIT 15;"
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/hetzner_key
          rm -f ${{ env.DUMP_PATH }}

  # =====================================================================
  # FINAL SUMMARY
  # =====================================================================
  summary:
    needs: [validate-inputs, deploy-code, sync-database]
    if: always()
    runs-on: self-hosted
    steps:
      - name: "üìã Final Summary"
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Final Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Phase | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY

          # Code Deploy status
          if [ "${{ inputs.deploy_code }}" = "true" ]; then
            case "${{ needs.deploy-code.result }}" in
              success)  echo "| üöÄ Code Deploy (\`${{ inputs.branch }}\`) | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY ;;
              failure)  echo "| üöÄ Code Deploy (\`${{ inputs.branch }}\`) | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY ;;
              skipped)  echo "| üöÄ Code Deploy | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY ;;
              *)        echo "| üöÄ Code Deploy | ‚ö†Ô∏è ${{ needs.deploy-code.result }} |" >> $GITHUB_STEP_SUMMARY ;;
            esac
          else
            echo "| üöÄ Code Deploy | ‚ûñ Not requested |" >> $GITHUB_STEP_SUMMARY
          fi

          # DB Sync status
          if [ "${{ inputs.sync_database }}" = "true" ]; then
            case "${{ needs.sync-database.result }}" in
              success)  echo "| üóÑÔ∏è Database Sync | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY ;;
              failure)  echo "| üóÑÔ∏è Database Sync | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY ;;
              skipped)  echo "| üóÑÔ∏è Database Sync | ‚è≠Ô∏è Skipped |" >> $GITHUB_STEP_SUMMARY ;;
              *)        echo "| üóÑÔ∏è Database Sync | ‚ö†Ô∏è ${{ needs.sync-database.result }} |" >> $GITHUB_STEP_SUMMARY ;;
            esac
          else
            echo "| üóÑÔ∏è Database Sync | ‚ûñ Not requested |" >> $GITHUB_STEP_SUMMARY
          fi

          # Duration
          START=${{ needs.validate-inputs.outputs.start_time }}
          if [ -n "$START" ]; then
            DURATION=$(( $(date +%s) - START ))
            MINUTES=$(( DURATION / 60 ))
            SECONDS=$(( DURATION % 60 ))
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚è±Ô∏è **Total duration:** ${MINUTES}m ${SECONDS}s" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Fail if any phase failed
          FAILED=false
          if [ "${{ needs.deploy-code.result }}" = "failure" ]; then FAILED=true; fi
          if [ "${{ needs.sync-database.result }}" = "failure" ]; then FAILED=true; fi

          if [ "$FAILED" = "true" ]; then
            echo "> ‚ùå **Some steps failed.** Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "> ‚úÖ **All requested operations completed successfully!**" >> $GITHUB_STEP_SUMMARY
          fi
